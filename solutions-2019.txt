All entries comprise 7 parts which are OJ-ID, author, date of submission, tags, description modeling, major steps to solve it, warnings, with a colon stands between each pair of parts. When a new line is created, a hyphen is require for its previous line at the end.
Each entry ends with a full stop and a blank line stands between any two neighbouring entries.

poj-3307;Caution_X;20191022;math;-
定义一个数为“生产力数”：该数可由其他数每个位上的数相乘得来，那么这个数就叫“生产力数”-
现在对所有的生产力数从小到大排序，输入i，输出第i个生产力数;-
(1) 由其他数每个位上的数相乘得来 => 该数可由1~9相乘得来 => 该数可由质数2,3,5,7（唯一分解定理）相乘得来-
(2) 枚举所有仅由2，3，5，7相乘得来的数，排序即可;-
我们用来存生产力数的数组的大小是自己开的，由于事先不确定由多少个生产力数，所以数组可以开的大一点，当时开到[80000]就AC了.

CodeForce-208B;Caution_X;20191022;dfs;-
有n张牌排成一排，从最后一张往前看，假设此时最后一张牌位置在x-
那么如果x-3位置或者x-1位置的牌和x位置的牌有相同的值或者相同的花色，那么就可以把第x张牌放在第x-3或者第x-1张牌上面，以此类推-
问：能否完成n-1次合并;-
(1) 首先预处理所有的牌，用M[i][j]来表示第i位置的牌可不可以叠在第j位置的牌上-
(2) 然后dfs，如果遇到当前状态的牌无法继续往下叠，那么记录当前状态作为其他支路的剪枝;-
记忆化搜索，暴搜TLE.

hdu-5478;Caution_X;20191022;math;-
输入C,k1,b1,k2,要求输出所有符合a^(k1*n+b1) + b^(k2*n-k2+1) = 0  (mod C) && (1<=a,b<C)  (n=0,1,2,3.......)的(a,b);-
当n=0时 a^(b1)+b^(1-k2) = 0 (mod C) -----①-
当n=1时 a^(k1+b1)+b = 0 (mod C) ------②-
将①*a^k1 得到 a^(k1+b1) +b*(a^k1 / b^k2) = 0 (mod C) ------③-
比较②和③可以得到a^k1=b^k2 (mod C) -
又b=C-a^(k1+b1) (mod C)，所以只要暴力枚举a的值代入式子 a^k1=b^k2 (mod C) 即可，若相等则当前(a,b)可行;.

hdu-5584;Caution_X;20191021;math;-
青蛙跳，每次移动从(x,y)->(x,y+lcm(x,y))或(x,y)->(x+lcm(x,y),y);-
设当前位置(at,bt)，则下一步为(at(1+b),bt)或(at,bt(1+a))-
那么反过来推，可以得到当前步(at,bt)，则上一步为(at,bt/(a+1))或(at/(1+b),bt)-
以此类推直到b无法被(1+a)整除或者a无法被(1+b)整除;.

hdu-5573;Caution_X;20191021;construction;-
给定一个完全二叉树，从上向下遍历节点，对于每一个节点可以选择相加或者相减，目标是在第K层达到值为N;-
（1）根据二进制数的原理，第K层的数可以由1，2，4，8，........，2^(K-1)来表示 （因此本题和二叉树实际上没有什么关系）-
（2）我们只要在1，2，4，8，........，2^(K-1)，[2^(K)(奇数)或者2^(K)+1(偶数)]中选择数进行相加或者相减即可-
（3）首先将所有1，2，3，4，.......，2^K相加得到Sum，之后再选择哪些数应该要相减，对于相减的数应该减去2*(2^i)，-
直到所减数之和为Sum-N，不妨取sum=(Sum-N)/2，判断是否应该相减只要判断该数在sum的二进制位上是否为1，为1则应该减去，否则不应该减去;.

CodeForces-574D;Caution_X;20191019;dp;-
给定一个有小正方形组成的不规则图形，现在进行操作:每次都消去暴露在外面的小正方形，问需要几次操作才能消去所有小正方形？;-
(1) dp1[i]:=以第i列为最后一列从前往后可以得到的连续上升子序列-
(2) dp2[i]:=以第i列为最后一列从后往前可以得到的连续上升子序列-
备注：此处连续上升子序列是指可以找到排列成阶梯状的连续上升格子，例如小正方形排列为3 3 3 ，此时仍有连续上升子序列1(3) 2(3) 3 -
(3) 对每一列dp取min（dp1,dp2），ans=max(dp[i]);.

poj-3256;Caution_X;20191019;dfs;-
有n个岛，岛之间有单向边，每个岛都有牛，共k头牛，问有几个岛可以使得牛能够聚会;-
(1) dfs得出每个岛能够使多少牛到来-
(2) 若该岛能够使k头牛都到，则该岛满足条件;.

CodeForce-577B;Caution_X;20191019;dp;-
给一个序列，找一个子序列使之mod m =0;-
dp[i]:表示取模后得到了i-
遍历序列，对每一个元素更新dp，判断能否得到dp[0];.

poj-3230;Caution_X;20191019;dp;-
某人去旅行一趟，输入包含从城市i->j的花费cost[i][j]和第i天待在城市j可以得到的钱w[i][j]，求m天后的最大钱数;-
dp[i][j]:=第i天待在第j个成=城市得到的最大金钱-
dp[i][j]=max(dp[i][j],dp[i-1][k]-cost[k][j]+w[i][j]);.

hdu-1704;Caution_X;20191017;dfs;-
n个人，m场比赛，输出有多少种选择(a,b)使得不知道a,b谁胜谁负;-
(1) dfs每一个人的比赛，将所有的间接战胜表示出来（间接战胜:a->b,b->c   =>  a->c）-
(2) 遍历所有人的比赛，得出答案;.

poj-3258;Caution_X;20191017;binary search;-
一条河有m个石头，每个石头位置a[i](a[0]=0,a[m+1]=n//n是河的长度)，从中移除k个石头，最大化两个石头之间的最小值;-
(1)二分枚举石头间距离的最小值，统计达到这个最小值需要移除的石头数-
(2)如果石头数<=k，所有这个最小距离还可以更大，否则说明这个最小距离过大了;-
当石头数==k时不代表这个最小距离是最优解.
 
hdu-6029;Caution_X;20191017;implementation;-
给定n个点，除第一个点外每一个点有两种操作：-
操作1：选择一个比该点小的点匹配-
操作2：该点之前的点不得与该点匹配-
问：最终能否达到完美匹配;-
(1)显然n为奇数不可能，当n为偶数时进入(2)-
(2)从后往前遍历，保证操作1的个数始终大于操作2的个数即可;.

CodeForce-192D;Caution_X;20191017;greedy;-
n个广场，每个广场都有相应的使用费，现在反对派有m天时间，政府有k块钱，反对派想要尽可能使用点数小的广场，-
现在反对派每天可以申请一个广场，政府则会用手上的钱租用这个广场（除非政府没钱或者这个广场是最后一个广场），问反对派可以拿到的最好的广场。;-
(1)为了结果最优，假定反对派在最后一天到来之前都挑选最贵的广场-
(2)到了最后一天:从广场1开始遍历，如果我们选择的这个广场在之前还没有被使用，那么这个广场就是最优广场，如果这个广场在之前已经被使用过了，那么我们就找找有没有还没有使用过的广场（序号偏后）可以替代这个广场;.

CodeForce-222C;Caution_X;20191012;math;-
给出分子分母，求通分。（分子分母以一系列数的乘积给出）;-
(1)分别把分子分母分解质因数-
(2)通分;-
分解质因数后有两种处理方案：-
①：比较分解后分子分母的质因数，然后消去分子分母中相同的质因数（导致(溢出)WA和TLE）-
②：用原来分子的乘积和分母的质因数相消，再用原来分母的乘积和分子的质因数相消-
采用方案②.

CodeForce-176C;Caution_X;20191012;implementation;-
给定一个棋盘，两个棋子，双方轮流操作，A先走，每次移动一个棋子在相邻格子一格，B后走，每次可以在一个格子涂胶水，如果两个棋子可以重合，A赢，否则B赢;-
(1)如果棋盘“非常大”，可以猜想B一定会赢-
(2)此时我们讨论A赢得极限情况。-
设开始时两个棋子分别在棋盘左上角和右下角，棋盘规模为:-
1×5-
2×5-
3×5-
4×4-
时A恰好赢，其他情况下A都无法赢;.

hdu-1030;Caution_X;20191010;math;-
给定图，问两个数字之间的“距离”;-
将给定图分为3个图，两个数字之间的距离就是两个数字分别在3个图中的距离之和，三个图分别是原图中抽离出只有横线，只有右斜线和只有左斜线;.

poj-1007;Caution_X;20191010;implementation;-
输入若干个字符串，按“有序”到“无序”顺序输出（这些串只含有A,C,G,T）-
有序的定义为该串的逆序数，若逆序数相同，则按原来的顺序输出;-
(1)记录所在串各个字母的个数-
(2)遍历整个串，每次遍历到当前字母时加上与该字母逆序的字母的个数，然后该串中此字母个数-1-
(3)sort排序后输出;-
注意审题，逆序数相同时按照原来的顺序输出.

hdu-1219;Caution_X;20191010;STL;-
输入一段话，输出这段话各个小写字母出现的次数;-
(1)输出时每个样例之间有空行-
(2)map<>需要clear;.

poj-3404;Caution_X;20191010;greedy;-
n个人过桥，每个人过桥用时已给出，桥只能承载两个人，过河需要火炬，但是只有一个火炬，问最短过河时间;-
(1)两个人过桥之后需要有人把火炬送回来-
(2)以未过桥的四个人为一个单位，记为a,b,c,d其中a最快，b次快，c最慢，d次慢，分两种情况，①：每次都由最快的人把火炬送回来②：由最快帮助最慢过河，次快帮助次慢过河,步骤为a,b先过河，然后a回来，c,d一起过河，然后b回来带a过河-
两种方式耗时为：①：2a+c+d ②：2b+a+c-
(3)每次以四人为单位选择过河方式直到剩下的人不足四人为止;-
思维误区：容易认为方案一是唯一最有效方案.

CodeForce-359C;Caution_X;20191004;math;-
计算s,t的gcd。-
输入a0,a1,a2,.....an,x-
s=x^(a0+a1+a2+....+an)-
t=x^(a1+a2+...+an)+x^(a0+a2+a3+....+an)+.....+x^(a0+a1+a2+.....+a(n-1));-
(1)提取分子上幂最小的数（根据t,s的关系可知该数一定可以和s整除）-
(2)比较提取的幂和(a0+a1+...an)的大小-
(3)快速幂取模输出答案;-
分子可能比分母大.

poj-3624;Caution_X;20191006;01 knapsack;-
01 knapsack模板题;-
(1)dp[i]:=容量为i时的最大价值-
(2)dp[j]=max(dp[j],dp[j-w[i]]+v[i]);-
space optimization.

poj-2803;Caution_X;20191004;implementation;-
处理至多一个前缀和后缀;-
(1)先处理前缀后将字符串前缀删去-
(2)处理后缀;.

poj-2782;Caution_X;20191004;greedy;-
把n个东西装箱，每个东西有权值a[i]，每个箱最多装两个且最多装权值和为k，问最少要几个箱子？;-
(1)按权值从大到小排序-
(2)权值最大的东西i和权值最小的东西j装在一起同时i++,j--，如果不能把最大最小装在一起，就只装权值最大的东西同时i++;.

poj-2935;Caution_X;20191004;bfs;-
走迷宫问题，问最小步数;-
(1)建图：因为本题的点和墙比较特殊，先把地图扩大到原来两倍再处理-
(2)常规bfs;-
注意本题的建图.

CodeForce-359C;Caution_X;20191004;math;-
计算s,t的gcd。-
输入a0,a1,a2,.....an,x-
s=x^(a0+a1+a2+....+an)-
t=x^(a1+a2+...+an)+x^(a0+a2+a3+....+an)+.....+x^(a0+a1+a2+.....+a(n-1));-
(1)提取分子上幂最小的数（根据t,s的关系可知该数一定可以和s整除）-
(2)比较提取的幂和(a0+a1+...an)的大小-
(3)快速幂取模输出答案;-
分子可能比分母大.

CodeForces-574D; Kaeya; 20191018; dp;-
n列，每一列有Ai个方块，每次删除没有被包围的方块，问多少次删完;-
(1)三角型需要一层一层的删除，如1 2 1需要两次删除-
(2)最大的三角型删除的同时，其他的小三角型会被删除，所以问题转化为找最大的三角型-
两个dp数组，分别记录从左向右和从右向左的最长连续上升子串，两个dp相同位置的最小值即为该位置三角型的高度，所有三角型的高度的最大值即为所求;.

CodeForces-577B; Kaeya; 20191018; dp;-
n个数，问是否存在一个子序列使得，所有数的和被m整除;-
(1)子序列数的和被m整除即%m==0，问题转化为多个数的和%m的余数是否为0-
(2)子序列前面出现过的余数可以在此基础上加上或者不加新的数，问题可以转化为背包-
用dp记录能取到的除以m的余数，从第一个数开始，加上和不加上下一个数的余数都记录下来，由于取模dp向一个方向会出现重复取同一个数的情况，可以用滚动数组解决;.

POJ-3404;xxmlala;20191012;mathematics;-
n个极限速度不同的人要过桥，一开始所有人在桥的一边，每次最多两个人同时过桥，过桥时需要用一把火炬并且全场只有一把火炬，问所有人到达桥的另外一边所需最短时间;-
(1)凭直觉很多人都会立刻想到每次都让最快的人在桥两边来回陪同其他人过桥，但是当遇到类似于1  2    10  11，这种，最优解为   1 2，1，10 11，2，1 2，并不是1 2，1，1 10，1，1 11.-
(2)设a最快，b次快，d次慢，c最慢，每次有两种策略可供选择（剩余人数大于等于4，其他情况很容易计算）：-
(2.1)1.a  b,a,c  d,b,-
(2.2)2.a  d,a,a  c,a.-
(2.3)每次对两种方案进行比较即可.

CodeForces-128D;xxmlala;20191012;greedy;-
给出一组数，要求将这些数排列成一个环，满足每相邻两个数的差值为1，问能否完成;-
先取出最小的数min，作为环中一点，则如果能够完成排列，该数两侧的数字即为min+1，如果min有多个，则放在min+1旁边，重复这样的过程，使用list可以很容易地完成.

POJ-1941;xxmlala;20191012;ditui;-
用‘\’,'/','_'按照给定规则画出三角形;-
思路：题中的三角形生成规则是符合递推关系的，可以先手动完成第一个三角形，再根据题中规律逐级递推，推出每个三角形的图案，需要的时候直接查询即可;-
注：输出时不能用%C，会超时，除此之外，每一行行末多余的空格也时不能输出同时也没必要输出的，因此需要处理图案时在行末手动加上‘\0',再以%s输出.

POJ-3414;xxmlala;20191012;BFS;-
有两个有着固定容量的茶壶，初始时都为空，要求用FILL，POUR，DROP三种操作来准确地得到C值，输出最少次数及操作方案;-
以两茶壶均为空为初始状态，每次对六种操作进行枚举，BFS加记录路径即可.

CodeForces-359C;xxmlala;20191012;number theory;-
已知X，数组arr[n],求一个分式的分子与分母的最大公因数。分子为ΣX^arr[i],分母为X^Σarr[i]，数组为不递减序列;-
(1)容易想到，分子的最低次幂即可能为所需答案-
(2)由于arr里存在相同的数，因此分子的各个幂存在可以合并同类项的情况，所以应该先彻底完成合并同类项，再进行步骤1-
(3)一个小技巧，并不需要完成所有项的合并，当且仅当当前最小项的系数可以被X整除时才需要继续合并，否则当前项的次数即为答案所需次数;-
特别需要注意的是：完成合并后，分子的最低次幂的次数是有可能大于分母的次数的，所以应该取二者的较小值作为答案的次数.

HihoCoder-1636;xxmlala;20191012;DP;-
有n堆石头，盘古每次可以选择连续的x堆合并，所需时间为x堆石头的数量之和，x∈[l,r],现在要求，能否将石头合并成一堆，如果能，最短时间是多少;-
(1)区间DP的运用，DP[i][j][k],表示当前状态下[i,j]这个区间分成了k堆-
(2)状态转移：-
(2.1)k=1时，dp[i][j][k]=min(dp[i][j][D]+num[j]-num[i-1]),其中D∈[l,r],-
(2.2)k!=1时，dp[i][j][k]=min(dp[i][z][1]+dp[z+1][j][k-1]),（合并成k堆时，可以转化为k-1堆与1堆合并，此时就是区间DP的思路了）.

CodeForces-125D;xxmlala;20191012;constructive algorithms,greedy;-
将一列数划分为两个等差数列;-
(1)主要运用了鸽巢原理-
(2)假如能完成题设操作，则前三个数中，必有至少两个数在同一序列，枚举三种情况（a1 a2,a2 a3,a1 a3分别为等差数列的前两项）;-
注：枚举情况时，如果操作失败，则将已成功生成的等差数列末项划分到另一个数列试试（稍作思考即可）.

hdu-1051; Kaeya; 20191008; dp;-
有一台切木头的机器，切第一个需要耗费时间1，如果接着切长度l和重量w均大于等于前一个木头的l’和w’，则不需要花费时间，给n个木头，以及每个木头的l和w，问最少需要多少时间切完;-
(1)假设l由小到大排序，此时w如果也满足小到大，则可以放在一组切，一共花费时间1-
将一个维度排序，保证一个值递增，在剩下的一个维度找有多少个最长不下降子序列，即求最长下降子序列长度，(n<=10^5)需要用O(nlogn)的dp求法;.

CodeForces-148E; Kaeya; 20191007; dp;-
有n个架子，每个架子上有Ai个物品摆成一排，每次只能从一个架子的左端或右端取一个物品，一共取m个物品，求能取得的最大价值;-
(1)每个架子取了k个物品后不影响其他架子取的情况，无后效性-
(2)每个架子取k个物品有最优解，可以用dp求解，dpr[i][j]表示左边取i个右边取j个的价值-
最后问题转换为m容量的背包取n个物品，每个物品的重量与对应价值在(2)中求得，dp[i][j]表示前i个架子取j个物品的最大价值;.

POJ-1941; Kaeya; 20191006; implementation;-
n=1一个三角形，n=2三个n=1的三角形组成的大三角形，依此类推，给定n(n<=10)输出对应三角形;
很容易想到递归解决，但实现需要一定思维，递归时同时记录偏移值，初始化数组时直接赋值上空格免去麻烦，输出时使用字符串输出（单个会超时）;.

POJ-3414; Kaeya; 20191006; bfs;-
两个水壶分别可以装a，b的水，3个操作，把水壶装满，倒空水壶，从一个倒入另一个，求最小步数得到c的水量(a,b<=100);-
分支的情况很多而且复杂，没有简单的思路，但是总情况并不多a*b=10^4，用bfs找出最小步数，并记录过程即可;.

CodeForces-128D; Kaeya; 20191006; implementation;-
给n个数字，问能否围成一个环，且满足相邻的两个数相差为1;-
(1)最小的数只能与次小的数相邻-
(2)与最小的数组合完，剩下的次小的数只能与次次小的数相邻，依次类推-
(3)当比前一个数大1的个数大于前一个数的个数，并且两端均为前一个数，则把他放在两端，比如212-
(4)只在乎能不能成环，所以只用记录链两端的数，最后判断首位相接是否满足条件-
统计每个数的个数，从最小的数开始，记录两端的数，把所有数加进来之后判断(4);.

CodeForces-358D; Kaeya; 20191004; DP;-
给n只兔子喂食，每只兔子可以获得好感度a或b或c，a表示相邻的兔子还没有喂食能获得的好感度，b表示相邻的有一只兔子先喂食了，c表示相邻的两只都喂食了;-
从前向后，两种状态，下一只兔子先喂食和这一只兔子先喂食;.

CodeForces-122E; Kaeya; 20191002; Cantor expansion,math;-
给定n和k(n,k<=10^9)，求1~n的按字典序的第k个序列中，下标和对应位置的数都是幸运数字（只含4或7的数）的个数;-
(1)10^9内的幸运数只有1022个，用dfs搜索记录下来-
(2)13个数的全排列大于10^9，即对于n>13，只用对最后13个数康托展开-
把1~(n-13)的幸运数个数加起来，加上后面13个位置中满足条件的幸运数即可;.

CodeForces-119C; Kaeya; 20191002; dp;-
给定n天，m门课，数k，每门课作业量区间[a,b]和难度c。现要使每天一门课，并且每天难度递增，作业量是前一天的+k或*k(第一天在区间内任选)，并使总作业量最大;-
给课程按难度小到大排序，用三维数组记录所有状态————第i天选第j门课作业量为k时（a,b很大而b-a<=100，所以用k记录左端点的偏移量）的总作业量;.

CodeForces-119C;xxmlala;20191002;DP;-
从m门课选出n个排到n天，每天一门，难度须递增，每门课对应着一个作业量Xi，且Xi = Xi-1 + k or Xi - Xi-1 * k,总作业量要尽可能大,问能否排布，若能排布，求方案;-
建立一个三维DP数组，dp[i][j][k]，i表示第i天，j表示第i天时排了第j门课，k表示选择的作业量为第j门课作业区间的左端点＋k;
需要注意的地方是还应建立pre数组来标记DP路径.

poj-2217;xxmlala;20191002;suffix Array;-
求两个字符串的最长公共子串长度;-
后缀数组高度数组模板题.

CodeForces-109D;xxmlala;20191002;implementation;-
给出一组数，要求从小到大排序，并且排序的过程中，发生交换的两个数至少一个为幸运数（十进制位均为4或7），问能否在（2×n）次交换内完成排序，如果能，输出交换的方案（不要求步骤数最少）;-
首先分为两种情况：-
(1)所有的数均不为幸运数，则如果给出的序列已经排好序，答案为0,如果未排好序，则无法完成排序。-
(2)存在幸运数，可得，只要存在幸运数，就一定能在2×n次以内完成排序。-
(2.1)具体的处理方法是将序列分为若干个闭环，闭环的意思可以举个例子来看，（xio表示下标为xi的元素排序后所在位置下标）,如：x1->x2->x3->x1，这就是一个闭环，表示x1o==x2,x2o=x3,x3o=x1;-
(2.2)首先，一组数在上述规则下一定能分为若干闭环。-
(2.3)分完闭环后，正式进行交换，并且，确定一个幸运数作为操作数（需要且只需要一个），记录其所在闭环-
(2.3.1)首先，将操作数所在闭环进行排序（只需相邻之间两两交换即可，具体可参照上文对于闭环的定义）。-
(2.3.2)再借助操作数对剩余闭环依次排序。第一步为将操作数与待排序闭环中的任意元素交换，再用3.1中的方法操作，最后将操作数归位即可。-
(2.3.3)很容易证明，上述交换操作的总复杂度一定小于2×n.
      
poj-1695;xxmlala;20190930;DP;-
要求用三辆车往n座城市投递货物，起点都在一号城市，每辆车可以载任意数量的货物，投递顺序必须与城市编号递增序一致，并且，每次同时都只能有一辆车在跑路。求最短总路径之和;-
dp[i][j][k]=min(dp[i][j][k],dp[i+1][j][k]+g[i][i+1],dp[i+1][i][k]+g[j][i+1],dp[i+1][i][j]+g[k][i+1]);-
对于该方程-
(1)首先，i表示此时状态所到达的最大城市编号，j,k为其余两车所在城市-
(2)采用倒序状态转移，即由dp[n][j][k]逐步转移到dp[1][1][1]-
(3)三辆车完全相同，因此不需要考虑其顺序，某一时刻三辆车所处城市编号从大到小依次是i,j,k时，下一步可能是j->i+1,i->i+1,k->i+1.
    
HDU-1760; Kaeya; 20190930; dfs, game;-
n*m的棋盘上轮流放2*2的方块，最后一个不能放下的人输，问先放的人能不能赢;-
(1)能到达一个必败态的是必胜态-
(2)所有下一个状态为必胜态的是必败态-
(3)dfs找出必败态再往回推每一个状态即可;.

CodeForces-117C; Kaeya; 20190930; enumeration, graph;-
给定一个竞赛图（任意两点有且只有一条单向边），问是否存在三元环;-
(1)竞赛图必定能生成一条链（链中排在后面的点可以指向前面的所有点）-
(2)若链中靠前的点指向一个新点（不在链中），新点指向一个靠后的点则这三个点形成一个三元环-
(3)每次判断一个新点能否与链上的点形成三元环，如果可以则找到答案，若不能，则将该点添加到链中，重复此步骤;.

hdu-1493;Caution_X;20190930;DP;-
投掷10次骰子，掷出的点数概率已给出，问掷完后落在5, 12, 22, 29, 33, 38, 42, 46, 50 55点上的概率。;-
(1) dp[i][j]:=第j次投在第i格上的概率，p[]:=各个点的概率-
(2) dp[i][1]=p[i]-
(3) dp[i+k][j+1]+=dp[i][j]*p[k];.

CodeForce-125D;Caution_X;20191002;enumeration, combinatorics;-
给定一个序列，把它分成两个非空子序列，每一个序列都是等差序列，如果可以输出两个子序列，否则输出No solution;-
(1) 对每个数，要么在第一个子序列，要么在第二个子序列，根据鸽巢原理，将前三个元素放入两个数列必然有两个数在同一个数列，其中元素大于1的数列会形成一个公差，且公差d最多只有有三个值-
(2) 根据其中一个公差d生成一个等差数列，然后将剩下的数放在另一个数列，判断另一个数列是不是等差数列-
(3) 是等差数列则直接输出，否则将第一个数列尾部元素移到第二个数列，判断是否构成等差数列-
(4) 如果构成则输出，否则枚举其他公差值;-
对(3)->(4)中将其中一个数列尾部元素移至另一个数列时若还不构成等差数列则应该枚举其他公差的证明：-
从构造的等差数列里移动2个元素过来，假设，移动第一个后没有形成等差数列，移动第二个后形成了等差数列，那么这个新形成的等差数列公差和原来构建的等差数列的公差相等，也就是说这个新形成的等差数列和原来的等差数列可以放在同一个数列中，即：在拆成两个子序列之前，原数列就是等差数列,既然原数列是等差数列，那么在移动第一元素后新数列就已经是等差数列了，和我们假设的移动第一个后没有形成等差数列矛盾，因此得出：第一元素移动后没有形成等差数列，那么接下来无论移动多少个元素都不会形成等差数列，因此当第一个元素移动完之后若不是等差数列就直接枚举其他的公差.

poj-3041;Caution_X;20191002;bipartite graph;-
给定一个N×N的网格，网格上有很多的点，现在可以一次性消除某行或者某列上的所有点，问最少需要几次可以把所有的点都消除-
(1) 建立一个二分图，两边的点分别是横坐标和纵坐标，网格上出现的点（x,y）表示二分图左边的x可以和右边的y匹配-
(2) 当我们选择左边图的一个点x清除时，实际上就是把横坐标为x的点清除，那么与该点x匹配的右边图的所有点也会被一起清除，（选择右边点y清除同理）-
(3) 现在问题转换成了想要覆盖所有边的最少点数，即：二分图的最小匹配点数;-
(1) 建图-
(2) 二分图的最小匹配=二分图的最大覆盖-
二分图最大覆盖求法：-
(1) 选择左图的一个点x1，遍历与该点有关的边，在右图找到一个匹配点y1，连接2点(x1,y1)-
(2) 继续选择左图的点x2，如果该点对应的匹配点是y1，则查找x1有没有新的匹配点y2，若有，则(x1,y2),(x2,y1)，若没有，继续找x2的匹配点，如果遍历到最后都没有找到匹配点，则继续左图的下一个点，直到左图无点可用;.

poj-2060;Caution_X;20191002;bipartite graph;-
给定一个二维坐标图，从一个点a到另一个点b费时(a.x-b.x)+(a.y-b.y)，现在有n个出租车订单，每个订单提供起点终点坐标和用车时间，问最少需要几辆出租车才可以在用车时间内接完所有客人;-
(1) 假设我们派出了n辆出租车，如果两个订单恰好可以由一辆车完成，那么出租车数-1.-
(2) 建图：现在以一辆车能否在接完这单并且及时接下下一单为依据建立一个二分图，如果两个订单可以由一辆车接下，那么这两个订单设定成匹配状态-
(3) 算出最小路径覆盖（二分图最小路径覆盖：用最少的边覆盖所有的点）-
最小路径覆盖=N-二分图最大匹配;.

poj-2006;Caution_X;20190929;easy;-
给定电离平衡常数Ka，溶液未电离时的浓度C，1mol 酸的氢含量n和酸根含量m 计算PH;-
(1) 常规化学题的推导：设[H+]=x,[酸根]=y，则Ka=x*y/(C-y)--①,x/y=n/m--②，又PH=-log([H+])--③，联立①②③结合求根公式可得(2)中ans.-
(2) 记Ka=a,C=b,解得：ans=(-log10((-a+sqrt(a*a+(4.0*a*b*n*m)))/(2.0*m)));-
sqrt(n/m)会导致精度不足，用sqrt(n*m)/m来替代则AC.

hdu-1760;Caution_X;20190929;DFS, game;-
给定N×M的方格，0为可放方格，1为不可放方格，现在开始轮流放正方形方块，每个方块占4格，由A先开始放，问A能否必胜;-
(1) 博弈中的必胜态：当前所能到达的状态能到达一个必败态，则当前状态为必胜态。-
(2) 博弈中的必败态：若当前状态到达的所有状态都是必胜态，则当前状态为必败态。-
(3) DFS直到不能再放方块，则不能再放方块的那个状态为必败态，然后往前回溯直到最初的状态即可;.

CodeForce-117C;Caution_X;20190930;DFS;-
给定一个有向图，边权都为1，问能否找到权值和为3的环，找到则输出对应的点标号，否则输出-1;-
(1) vis[]表示该点是否访问过-
(2) 从一个未被访问过的点开始DFS，找到与该点相连且未被访问过的点继续DFS-
(3) 如果形成了环，结束DFS，否则继续2操作;.

hdu-1723;Caution_X;20190930;DP;-
给定N,M，表示有1~N个人排成一列，前一个人可以向后M个人传递消息，问第N个人有多少种方式接收第一个人传出的消息;-
(1) dp[i]:=第i个人接收消息的方式有几种-
(2) if(i-1<=M) dp[i]++-
(3) dp[i+j]+=dp[i] j∈{1,2,3......M};.

hdu-1719;Caution_X;20190930;math;-
Friend number are defined recursively as follows-
(1) numbers 1 and 2 are friend number-
(2) if a and b are friend numbers, so is ab+a+b-
(3) only the numbers defined in (1) and (2) are friend number-
Now your task is to judge whether an integer is a friend number;-
(1)设n是Friend数，则n=ab+a+b=(a+1)*(b+1)-1   =>   n+1=(a+1)*(b+1)-
(2)a,b都是Friend数,所以a+1=(a'+1)*(b'+1),b+1=(a''+1)*(b''+1)直到a,b=1,2-
(3)那么：n+1= 2^x * 3^y;-
0需要特判.

poj-1695;xxmlala;20190930;DP;-
要求用三辆车往n座城市投递货物，起点都在一号城市，每辆车可以载任意数量的货物，投递顺序必须与城市编号递增序一致，并且，每次同时都只能有一辆车在跑路。求最短总路径之和。-
DP:dp[i][j][k]=min(dp[i][j][k],dp[i+1][j][k]+g[i][i+1],dp[i+1][i][k]+g[j][i+1],dp[i+1][i][j]+g[k][i+1]);-
对于该方程-
(1)首先，i表示此时状态所到达的最大城市编号，j,k为其余两车所在城市-
(2)采用倒序状态转移，即由dp[n][j][k]逐步转移到dp[1][1][1]-
(3)三辆车完全相同，因此不需要考虑其顺序，某一时刻三辆车所处城市编号从大到小依次是i,j,k时，下一步可能是j->i+1,i->i+1,k->i+1;.

hdu-2973; xxmlala; 20190927; Waleson Theory;-
计算一个复杂代数式的值;-
威尔逊原理：对于素数p,有(p-1)!=-1( mod p).-
首先，将原式变形为[ (3×k+6)! % (3×k+7) + 1] / (3×k+7)，所以：-
(1)3×k+7是素数，结果为1,-
(2)3×k+7不是素数，则假设（3×k+7）=m1*m2*m3……，可知m1,m2,m3……<=3*k+6,则此时（3×k+6)! % (3×k+7) = 0,所以经过取整，式子的答案为0;.

poj-1313; Kaeya; 20190927; implementation;-
给一个n表示有1~n为有内容的页码，用最少的纸张做成折叠小册，使页码按册子翻页的顺序排好，从最外面的纸张开始输出每张纸上的正面反面的页码;-
每一面的页码对应一个最小一个最大，一个次大一个次小……以此类推，正面右半页为小页码，背面左半页为小页码，模拟即可。;.

CodeForces-580D; xxmlala; 20190927; States Compressing DP;-
每道菜都对应一个满意度，并且相互之间以特定的顺序排列有不同的满意度加成，从n道菜中选择m道，使得满意度最大;-
状态压缩dp裸题，以吃到的菜为状态，求解dp值即可;.

poj-1129; Caution_X; 20190927; DFS,graph theory,four colour theorem;-
给定n个点的无向连通图，问至少需要几种颜色可以完成染色;-
(1)任选从一点开始染色-
(2)DFS不断向其他点进行染色-
(3)所有点都染过色，结束DFS;.

hdu-1262; Caution_X; 20190927; brute force, Eular filter;-
给定一个数n，输出a,b满足a+b=n且a,b为素数且|a-b|最小;-
欧拉筛预处理素数，然后遍历所有素数即可，循环结束条件为素数大于n/2;.

CodeForce-113B; Caution_X; 20190927; DP;-
求多个数列的LCS;-
(1)dp[i]:表示以数字i结尾得到的LCS，pos[i][j]表示数字j再第i个数列的位置，cnt[i]表示数字i出现了几次-
(2)从每个数列第一个数开始往后遍历，当cnt[i]=k时说明i可以作为LCS的一部分了-
(3)接下来需要讨论一下，在LCS中加入i对答案的影响-
(4)我们用vector<>存入所有可以作为LCS一部分的值，然后遍历vector中的数，判断二者的pos，来决定i应该插入在哪一个位置-
(5)遍历完成后vector<>加入i并且重新从2步骤开始;.
