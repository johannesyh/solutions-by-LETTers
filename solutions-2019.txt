All entries comprise 7 parts which are OJ-ID, author, date of submission, tags, description modeling, major steps to solve it, warnings, with a colon stands between each pair of parts. When a new line is created, a hyphen is require for its previous line at the end.
Each entry ends with a full stop and a blank line stands between any two neighbouring entries.
 
poj-1104;Caution_X;20191024;implementation;-
给定一个矩形，现在给定四个点构成一个扫描矩形（扫描矩形在矩形内），表示该扫描矩形范围内没有盗贼-
现在给出N个这样的扫描矩形，每个扫描矩形都有对应的时间，表示该扫描发生的时间-
现在问能否通过N次扫描判断盗贼的状态（已逃离(离开给定的坐标范围)，不确定，或者确定在点（x,y））;-
vis[t][r][c]=1表示t时刻（r,c）处有盗贼-
（1）按照时间正向反向搜索两次，每次扫描的目的在于判断vis[t][r][c]为0的点应不应该是1-
（因为扫描矩形范围内是1不代表扫描矩形外一定是0，有一些点虽然在扫描矩形外，但它依然必须是1）-
（2）完成两次扫描之后遍历时间1~T状态下矩形的点，如果存在某个状态全为1，说明盗贼已经离开了矩形（已逃离）-
如果某个状态整个矩形只有一点是0，说明该状态下盗贼就在该点。如果所有时间的矩形都扫描过了而且没有得到盗贼的状态，输出不确定时的答案-
正向搜索方式：如果t时刻在(r,c)即vis[t][r][c]=0，那么t-1时刻必然在(r,c)周围（含(r,c)）的5个点内-
如果这5个点都是1，那么实际上vis[t][r][c]=1。反向搜索类似;.

hdu-6071;Caution_X;20191024;dp,dijkstra;-
有四个点1，2，3，4形成环1-2-3-4-1，四条边的权值表示距离，问能否找到一条路径从点2出发回到点2并且权值之和大于K;-
w=min(d1,d2)，其中d1是1，2之间的距离，d2是2，3之间的距离-
假设有符合条件的最小权值和P，那么就会有最佳的P-w -
设dp[i][j]:=从2出发到达i点时的最小权值和，其中j是权值和%(2*w)，之所以%(2*w)是因为从2出发再回到2权值和最少2*w-
同样是从2到达i点，不同的j表示不同的路径，若j相同但是从2到i的权值和不同，则选择权值和小的-
（1）dijkstra更新dp[i][j]-
（2）判断dp[2][j]是否大于K，若小于K则不足之处用w填充;.

poj-3307;Caution_X;20191022;math;-
定义一个数为“生产力数”：该数可由其他数每个位上的数相乘得来，那么这个数就叫“生产力数”-
现在对所有的生产力数从小到大排序，输入i，输出第i个生产力数;-
(1) 由其他数每个位上的数相乘得来 => 该数可由1~9相乘得来 => 该数可由质数2,3,5,7（唯一分解定理）相乘得来-
(2) 枚举所有仅由2，3，5，7相乘得来的数，排序即可;-
我们用来存生产力数的数组的大小是自己开的，由于事先不确定由多少个生产力数，所以数组可以开的大一点，当时开到[80000]就AC了.

CodeForce-208B;Caution_X;20191022;dfs;-
有n张牌排成一排，从最后一张往前看，假设此时最后一张牌位置在x-
那么如果x-3位置或者x-1位置的牌和x位置的牌有相同的值或者相同的花色，那么就可以把第x张牌放在第x-3或者第x-1张牌上面，以此类推-
问：能否完成n-1次合并;-
(1) 首先预处理所有的牌，用M[i][j]来表示第i位置的牌可不可以叠在第j位置的牌上-
(2) 然后dfs，如果遇到当前状态的牌无法继续往下叠，那么记录当前状态作为其他支路的剪枝;-
记忆化搜索，暴搜TLE.

hdu-5478;Caution_X;20191022;math;-
输入C,k1,b1,k2,要求输出所有符合a^(k1*n+b1) + b^(k2*n-k2+1) = 0  (mod C) && (1<=a,b<C)  (n=0,1,2,3.......)的(a,b);-
当n=0时 a^(b1)+b^(1-k2) = 0 (mod C) -----①-
当n=1时 a^(k1+b1)+b = 0 (mod C) ------②-
将①*a^k1 得到 a^(k1+b1) +b*(a^k1 / b^k2) = 0 (mod C) ------③-
比较②和③可以得到a^k1=b^k2 (mod C) -
又b=C-a^(k1+b1) (mod C)，所以只要暴力枚举a的值代入式子 a^k1=b^k2 (mod C) 即可，若相等则当前(a,b)可行;.

hdu-5584;Caution_X;20191021;math;-
青蛙跳，每次移动从(x,y)->(x,y+lcm(x,y))或(x,y)->(x+lcm(x,y),y);-
设当前位置(at,bt)，则下一步为(at(1+b),bt)或(at,bt(1+a))-
那么反过来推，可以得到当前步(at,bt)，则上一步为(at,bt/(a+1))或(at/(1+b),bt)-
以此类推直到b无法被(1+a)整除或者a无法被(1+b)整除;.

hdu-5573;Caution_X;20191021;construction;-
给定一个完全二叉树，从上向下遍历节点，对于每一个节点可以选择相加或者相减，目标是在第K层达到值为N;-
（1）根据二进制数的原理，第K层的数可以由1，2，4，8，........，2^(K-1)来表示 （因此本题和二叉树实际上没有什么关系）-
（2）我们只要在1，2，4，8，........，2^(K-1)，[2^(K)(奇数)或者2^(K)+1(偶数)]中选择数进行相加或者相减即可-
（3）首先将所有1，2，3，4，.......，2^K相加得到Sum，之后再选择哪些数应该要相减，对于相减的数应该减去2*(2^i)，-
直到所减数之和为Sum-N，不妨取sum=(Sum-N)/2，判断是否应该相减只要判断该数在sum的二进制位上是否为1，为1则应该减去，否则不应该减去;.

HDU-5573; Kaeya; 20191020; math;-
给一棵k层的完全二叉树，权值对应下标，给出n<=2^k，求一条从1到第k层的路，并使得路上的权值作加法或减法最后等于k;-
(1)n<=2^k，而且最左侧的点的权值与2进制位权值相同，当n<2^k,将最左侧的数相加必定大于n-
(2)最高位取负时得到的值为负，所以最高位一定取正-
(3)左侧数的和m减去其中一个数a，得到的数m-2a-
(4)由(3)，n为奇数时，(m-n)后得到需要减去的数的两倍，除以二后对应二进制的位权与左侧点权相同，即减去相应位权的点-
(5)n为偶数时，左侧最高位取第二个数则可以同上述奇数情况，此时n==2^k也满足条件-
所以根据n奇偶讨论即可;.

HDU-5584; Kaeya; 20191020; math;-
在点(x,y)时，取x，y的最小公倍数n，下一步可以走到(x+n,y)或(x,y+n)，现给出终点，问可能为起点的数目;-
(1)n一定为x和y的整数倍，则有x+n>y,y+n>x,所以当一个点确定，最多只有一个点能到达该点(或者没有)-
(2)问题转化为由终点逆推最远的起点，统计中间经过的点(包括自身)的个数即为答案-
(3)x,y任意一个加上n得到的新值的gcd仍保持不变-
由上面几点可得公式(Y为终点的较大值,则X=x)Y-lcm(x,y)=y，kx+y=Y(k为整数)，可推出k=Y/(gcd(X,Y)+X)若k不为整数则(X,Y)无法由其他点到达;.

HDU-5583; Kaeya; 20191020; math;-
给出一个01数组排成一行，最多可以改变一个数(0变1或1变0)，求所有连续相同字串的长度平方和;-
(1)平方和中，最大的数加一的平方增量大于任意一个数减一的平方的减少量，问题转换为求最长的子串(最长子串为整个串时除外)使其长度加一，相邻的较短串长度减一-
(2)如果减去长度1的子串长度本身为1，则此时得到的子串长度为将该减去的子串两端的子串长度相加再加1-
从左向右记录长度，将平方加到总和里，并比较相邻的两个串长度，按上述的思路找到最大的增值，最后在总和上加上增值即为答案;.

HDU-6071; Kaeya; 20191021; dijkstra;-
4个点围成正方形，一个点只能到相邻的两个点，从2号点出发，求回到2号点且大于路程大于k的最短距离;-
(1)取w=min(d12,d23),如果有一条路可以回到2号且路程为m，则m+2w(即再到相邻的点来回一次)也能回到2号-
(2)m%2w可以再走n个2w直至m+2wn刚好大于k,由此算得的m+2nw必定满足k<=(m+2wn)<k+2w-
(3)m%2w的余数有限，问题转换为求回到2号时，取得各个余数的最短路径-
用dijkstra求出所有上述路径，最后加上2w直至大于k后比较各个路径的长度,取最小值;.

CodeForce-574D;Caution_X;20191019;dp;-
给定一个有小正方形组成的不规则图形，现在进行操作:每次都消去暴露在外面的小正方形，问需要几次操作才能消去所有小正方形？;-
(1) dp1[i]:=以第i列为最后一列从前往后可以得到的连续上升子序列-
(2) dp2[i]:=以第i列为最后一列从后往前可以得到的连续上升子序列-
备注：此处连续上升子序列是指可以找到排列成阶梯状的连续上升格子，例如小正方形排列为3 3 3 ，此时仍有连续上升子序列1(3) 2(3) 3 -
(3) 对每一列dp取min（dp1,dp2），ans=max(dp[i]);.

poj-3256;Caution_X;20191019;dfs;-
有n个岛，岛之间有单向边，每个岛都有牛，共k头牛，问有几个岛可以使得牛能够聚会;-
(1) dfs得出每个岛能够使多少牛到来-
(2) 若该岛能够使k头牛都到，则该岛满足条件;.

CodeForce-577B;Caution_X;20191019;dp;-
给一个序列，找一个子序列使之mod m =0;-
dp[i]:表示取模后得到了i-
遍历序列，对每一个元素更新dp，判断能否得到dp[0];.

poj-3230;Caution_X;20191019;dp;-
某人去旅行一趟，输入包含从城市i->j的花费cost[i][j]和第i天待在城市j可以得到的钱w[i][j]，求m天后的最大钱数;-
dp[i][j]:=第i天待在第j个成=城市得到的最大金钱-
dp[i][j]=max(dp[i][j],dp[i-1][k]-cost[k][j]+w[i][j]);.

hdu-1704;Caution_X;20191017;dfs;-
n个人，m场比赛，输出有多少种选择(a,b)使得不知道a,b谁胜谁负;-
(1) dfs每一个人的比赛，将所有的间接战胜表示出来（间接战胜:a->b,b->c   =>  a->c）-
(2) 遍历所有人的比赛，得出答案;.

poj-3258;Caution_X;20191017;binary search;-
一条河有m个石头，每个石头位置a[i](a[0]=0,a[m+1]=n//n是河的长度)，从中移除k个石头，最大化两个石头之间的最小值;-
(1)二分枚举石头间距离的最小值，统计达到这个最小值需要移除的石头数-
(2)如果石头数<=k，所有这个最小距离还可以更大，否则说明这个最小距离过大了;-
当石头数==k时不代表这个最小距离是最优解.
 
hdu-6029;Caution_X;20191017;implementation;-
给定n个点，除第一个点外每一个点有两种操作：-
操作1：选择一个比该点小的点匹配-
操作2：该点之前的点不得与该点匹配-
问：最终能否达到完美匹配;-
(1)显然n为奇数不可能，当n为偶数时进入(2)-
(2)从后往前遍历，保证操作1的个数始终大于操作2的个数即可;.

CodeForce-192D;Caution_X;20191017;greedy;-
n个广场，每个广场都有相应的使用费，现在反对派有m天时间，政府有k块钱，反对派想要尽可能使用点数小的广场，-
现在反对派每天可以申请一个广场，政府则会用手上的钱租用这个广场（除非政府没钱或者这个广场是最后一个广场），问反对派可以拿到的最好的广场。;-
(1)为了结果最优，假定反对派在最后一天到来之前都挑选最贵的广场-
(2)到了最后一天:从广场1开始遍历，如果我们选择的这个广场在之前还没有被使用，那么这个广场就是最优广场，如果这个广场在之前已经被使用过了，那么我们就找找有没有还没有使用过的广场（序号偏后）可以替代这个广场;.

CodeForce-222C;Caution_X;20191012;math;-
给出分子分母，求通分。（分子分母以一系列数的乘积给出）;-
(1)分别把分子分母分解质因数-
(2)通分;-
分解质因数后有两种处理方案：-
①：比较分解后分子分母的质因数，然后消去分子分母中相同的质因数（导致(溢出)WA和TLE）-
②：用原来分子的乘积和分母的质因数相消，再用原来分母的乘积和分子的质因数相消-
采用方案②.

CodeForce-176C;Caution_X;20191012;implementation;-
给定一个棋盘，两个棋子，双方轮流操作，A先走，每次移动一个棋子在相邻格子一格，B后走，每次可以在一个格子涂胶水，如果两个棋子可以重合，A赢，否则B赢;-
(1)如果棋盘“非常大”，可以猜想B一定会赢-
(2)此时我们讨论A赢得极限情况。-
设开始时两个棋子分别在棋盘左上角和右下角，棋盘规模为:-
1×5-
2×5-
3×5-
4×4-
时A恰好赢，其他情况下A都无法赢;.

hdu-1030;Caution_X;20191010;math;-
给定图，问两个数字之间的“距离”;-
将给定图分为3个图，两个数字之间的距离就是两个数字分别在3个图中的距离之和，三个图分别是原图中抽离出只有横线，只有右斜线和只有左斜线;.

poj-1007;Caution_X;20191010;implementation;-
输入若干个字符串，按“有序”到“无序”顺序输出（这些串只含有A,C,G,T）-
有序的定义为该串的逆序数，若逆序数相同，则按原来的顺序输出;-
(1)记录所在串各个字母的个数-
(2)遍历整个串，每次遍历到当前字母时加上与该字母逆序的字母的个数，然后该串中此字母个数-1-
(3)sort排序后输出;-
注意审题，逆序数相同时按照原来的顺序输出.

hdu-1219;Caution_X;20191010;STL;-
输入一段话，输出这段话各个小写字母出现的次数;-
(1)输出时每个样例之间有空行-
(2)map<>需要clear;.

poj-3404;Caution_X;20191010;greedy;-
n个人过桥，每个人过桥用时已给出，桥只能承载两个人，过河需要火炬，但是只有一个火炬，问最短过河时间;-
(1)两个人过桥之后需要有人把火炬送回来-
(2)以未过桥的四个人为一个单位，记为a,b,c,d其中a最快，b次快，c最慢，d次慢，分两种情况，①：每次都由最快的人把火炬送回来②：由最快帮助最慢过河，次快帮助次慢过河,步骤为a,b先过河，然后a回来，c,d一起过河，然后b回来带a过河-
两种方式耗时为：①：2a+c+d ②：2b+a+c-
(3)每次以四人为单位选择过河方式直到剩下的人不足四人为止;-
思维误区：容易认为方案一是唯一最有效方案.

CodeForce-359C;Caution_X;20191004;math;-
计算s,t的gcd。-
输入a0,a1,a2,.....an,x-
s=x^(a0+a1+a2+....+an)-
t=x^(a1+a2+...+an)+x^(a0+a2+a3+....+an)+.....+x^(a0+a1+a2+.....+a(n-1));-
(1)提取分子上幂最小的数（
