All entries comprise 7 parts which are OJ-ID, author, date of submission, tags, description modeling, major steps to solve it, warnings, with a colon stands between each pair of parts. When a new line is created, a hyphen is require for its previous line at the end.
Each entry ends with a full stop and a blank line stands between any two neighbouring entries.

CodeForces-119C;xxmlala;20191002;DP;-
从m门课选出n个排到n天，每天一门，难度须递增，每门课对应着一个作业量Xi，且Xi = Xi-1 + k or Xi - Xi-1 * k,总作业量要尽可能大,问能否排布，若能排布，求方案;-
建立一个三维DP数组，dp[i][j][k]，i表示第i天，j表示第i天时排了第j门课，k表示选择的作业量为第j门课作业区间的左端点＋k;
需要注意的地方是还应建立pre数组来标记DP路径.

poj2217;xxmlala;20191002;suffixArray;-
求两个字符串的最长公共子串长度;-
后缀数组高度数组模板题.

CodeForces-109D;xxmlala;20191002;implementation;-
给出一组数，要求从小到大排序，并且排序的过程中，发生交换的两个数至少一个为幸运数（十进制位均为4或7），问能否在（2×n）次交换内完成排序，如果能，输出交换的方案（不要求步骤数最少）;-
首先分为两种情况：-
(1)所有的数均不为幸运数，则如果给出的序列已经排好序，答案为0,如果未排好序，则无法完成排序。-
(2)存在幸运数，可得，只要存在幸运数，就一定能在2×n次以内完成排序。-
(2.1)具体的处理方法是将序列分为若干个闭环，闭环的意思可以举个例子来看，（xio表示下标为xi的元素排序后所在位置下标）,如：x1->x2->x3->x1，这就是一个闭环，表示x1o==x2,x2o=x3,x3o=x1;-
(2.2)首先，一组数在上述规则下一定能分为若干闭环。-
(2.3)分完闭环后，正式进行交换，并且，确定一个幸运数作为操作数（需要且只需要一个），记录其所在闭环-
(2.3.1)首先，将操作数所在闭环进行排序（只需相邻之间两两交换即可，具体可参照上文对于闭环的定义）。-
(2.3.2)再借助操作数对剩余闭环依次排序。第一步为将操作数与待排序闭环中的任意元素交换，再用3.1中的方法操作，最后将操作数归位即可。-
(2.3.3)很容易证明，上述交换操作的总复杂度一定小于2×n.
      
poj-1695;xxmlala;20190930;DP;-
要求用三辆车往n座城市投递货物，起点都在一号城市，每辆车可以载任意数量的货物，投递顺序必须与城市编号递增序一致，并且，每次同时都只能有一辆车在跑路。求最短总路径之和;-
dp[i][j][k]=min(dp[i][j][k],dp[i+1][j][k]+g[i][i+1],dp[i+1][i][k]+g[j][i+1],dp[i+1][i][j]+g[k][i+1]);-
对于该方程-
(1)首先，i表示此时状态所到达的最大城市编号，j,k为其余两车所在城市-
(2)采用倒序状态转移，即由dp[n][j][k]逐步转移到dp[1][1][1]-
(3)三辆车完全相同，因此不需要考虑其顺序，某一时刻三辆车所处城市编号从大到小依次是i,j,k时，下一步可能是j->i+1,i->i+1,k->i+1.
    
HDU-1760; Kaeya; 20190930; dfs, game;-
n*m的棋盘上轮流放2*2的方块，最后一个不能放下的人输，问先放的人能不能赢;-
(1)能到达一个必败态的是必胜态-
(2)所有下一个状态为必胜态的是必败态-
(3)dfs找出必败态再往回推每一个状态即可;.

CodeForces-117C; Kaeya; 20190930; enumeration, graph;-
给定一个竞赛图（任意两点有且只有一条单向边），问是否存在三元环;-
(1)竞赛图必定能生成一条链（链中排在后面的点可以指向前面的所有点）-
(2)若链中靠前的点指向一个新点（不在链中），新点指向一个靠后的点则这三个点形成一个三元环-
(3)每次判断一个新点能否与链上的点形成三元环，如果可以则找到答案，若不能，则将该点添加到链中，重复此步骤;.

hdu-1493;author;Caution_X;20190930;DP;-
投掷10次骰子，掷出的点数概率已给出，问掷完后落在5, 12, 22, 29, 33, 38, 42, 46, 50 55点上的概率。;-
(1) dp[i][j]:=第j次投在第i格上的概率，p[]:=各个点的概率-
(2) dp[i][1]=p[i]-
(3) dp[i+k][j+1]+=dp[i][j]*p[k];.

CodeForce 125D;Caution_X;20191002;enumeration, combinatorics;-
给定一个序列，把它分成两个非空子序列，每一个序列都是等差序列，如果可以输出两个子序列，否则输出No solution;-
(1) 对每个数，要么在第一个子序列，要么在第二个子序列，根据鸽巢原理，将前三个元素放入两个数列必然有两个数在同一个数列，其中元素大于1的数列会形成一个公差，且公差d最多只有有三个值-
(2) 根据其中一个公差d生成一个等差数列，然后将剩下的数放在另一个数列，判断另一个数列是不是等差数列-
(3) 是等差数列则直接输出，否则将第一个数列尾部元素移到第二个数列，判断是否构成等差数列-
(4) 如果构成则输出，否则枚举其他公差值;-
对(3)->(4)中将其中一个数列尾部元素移至另一个数列时若还不构成等差数列则应该枚举其他公差的证明：-
从构造的等差数列里移动2个元素过来，假设，移动第一个后没有形成等差数列，移动第二个后形成了等差数列，那么这个新形成的等差数列公差和原来构建的等差数列的公差相等，也就是说这个新形成的等差数列和原来的等差数列可以放在同一个数列中，即：在拆成两个子序列之前，原数列就是等差数列,既然原数列是等差数列，那么在移动第一元素后新数列就已经是等差数列了，和我们假设的移动第一个后没有形成等差数列矛盾，因此得出：第一元素移动后没有形成等差数列，那么接下来无论移动多少个元素都不会形成等差数列，因此当第一个元素移动完之后若不是等差数列就直接枚举其他的公差.

poj-3041;Caution_X;20191002;bipartite graph;-
给定一个N×N的网格，网格上有很多的点，现在可以一次性消除某行或者某列上的所有点，问最少需要几次可以把所有的点都消除-
(1) 建立一个二分图，两边的点分别是横坐标和纵坐标，网格上出现的点（x,y）表示二分图左边的x可以和右边的y匹配-
(2) 当我们选择左边图的一个点x清除时，实际上就是把横坐标为x的点清除，那么与该点x匹配的右边图的所有点也会被一起清除，（选择右边点y清除同理）-
(3) 现在问题转换成了想要覆盖所有边的最少点数，即：二分图的最小匹配点数;-
(1) 建图-
(2) 二分图的最小匹配=二分图的最大覆盖-
二分图最大覆盖求法：-
(1) 选择左图的一个点x1，遍历与该点有关的边，在右图找到一个匹配点y1，连接2点(x1,y1)-
(2) 继续选择左图的点x2，如果该点对应的匹配点是y1，则查找x1有没有新的匹配点y2，若有，则(x1,y2),(x2,y1)，若没有，继续找x2的匹配点，如果遍历到最后都没有找到匹配点，则继续左图的下一个点，直到左图无点可用;.

poj-2060;Caution_X;20191002;bipartite graph;-
给定一个二维坐标图，从一个点a到另一个点b费时(a.x-b.x)+(a.y-b.y)，现在有n个出租车订单，每个订单提供起点终点坐标和用车时间，问最少需要几辆出租车才可以在用车时间内接完所有客人;-
(1) 假设我们派出了n辆出租车，如果两个订单恰好可以由一辆车完成，那么出租车数-1.-
(2) 建图：现在以一辆车能否在接完这单并且及时接下下一单为依据建立一个二分图，如果两个订单可以由一辆车接下，那么这两个订单设定成匹配状态-
(3) 算出最小路径覆盖（二分图最小路径覆盖：用最少的边覆盖所有的点）-
最小路径覆盖=N-二分图最大匹配;.

poj-2006;Caution_X;20190929;easy;-
给定电离平衡常数Ka，溶液未电离时的浓度C，1mol 酸的氢含量n和酸根含量m 计算PH;-
(1) 常规化学题的推导：设[H+]=x,[酸根]=y，则Ka=x*y/(C-y)--①,x/y=n/m--②，又PH=-log([H+])--③，联立①②③结合求根公式可得(2)中ans.-
(2) 记Ka=a,C=b,解得：ans=(-log10((-a+sqrt(a*a+(4.0*a*b*n*m)))/(2.0*m)));-
sqrt(n/m)会导致精度不足，用sqrt(n*m)/m来替代则AC.

hdu-1760;Caution_X;20190929;DFS, game;-
给定N×M的方格，0为可放方格，1为不可放方格，现在开始轮流放正方形方块，每个方块占4格，由A先开始放，问A能否必胜;-
(1) 博弈中的必胜态：当前所能到达的状态能到达一个必败态，则当前状态为必胜态。-
(2) 博弈中的必败态：若当前状态到达的所有状态都是必胜态，则当前状态为必败态。-
(3) DFS直到不能再放方块，则不能再放方块的那个状态为必败态，然后往前回溯直到最初的状态即可;.

CodeForce 117C;Caution_X;20190930;DFS;-
给定一个有向图，边权都为1，问能否找到权值和为3的环，找到则输出对应的点标号，否则输出-1;-
(1) vis[]表示该点是否访问过-
(2) 从一个未被访问过的点开始DFS，找到与该点相连且未被访问过的点继续DFS-
(3) 如果形成了环，结束DFS，否则继续2操作;.

hdu-1723;Caution_X;20190930;DP;-
给定N,M，表示有1~N个人排成一列，前一个人可以向后M个人传递消息，问第N个人有多少种方式接收第一个人传出的消息;-
(1) dp[i]:=第i个人接收消息的方式有几种-
(2) if(i-1<=M) dp[i]++-
(3) dp[i+j]+=dp[i] j∈{1,2,3......M};.

hdu-1719;Caution_X;20190930;math;-
Friend number are defined recursively as follows-
(1) numbers 1 and 2 are friend number-
(2) if a and b are friend numbers, so is ab+a+b-
(3) only the numbers defined in (1) and (2) are friend number-
Now your task is to judge whether an integer is a friend number;-
(1)设n是Friend数，则n=ab+a+b=(a+1)*(b+1)-1   =>   n+1=(a+1)*(b+1)-
(2)a,b都是Friend数,所以a+1=(a'+1)*(b'+1),b+1=(a''+1)*(b''+1)直到a,b=1,2-
(3)那么：n+1= 2^x * 3^y;-
0需要特判.

poj-1695;xxmlala;20190930;DP;-
要求用三辆车往n座城市投递货物，起点都在一号城市，每辆车可以载任意数量的货物，投递顺序必须与城市编号递增序一致，并且，每次同时都只能有一辆车在跑路。求最短总路径之和。-
DP:dp[i][j][k]=min(dp[i][j][k],dp[i+1][j][k]+g[i][i+1],dp[i+1][i][k]+g[j][i+1],dp[i+1][i][j]+g[k][i+1]);-
对于该方程-
(1)首先，i表示此时状态所到达的最大城市编号，j,k为其余两车所在城市-
(2)采用倒序状态转移，即由dp[n][j][k]逐步转移到dp[1][1][1]-
(3)三辆车完全相同，因此不需要考虑其顺序，某一时刻三辆车所处城市编号从大到小依次是i,j,k时，下一步可能是j->i+1,i->i+1,k->i+1;.

hdu-2973; xxmlala; 20190927; Waleson Theory;-
计算一个复杂代数式的值;-
威尔逊原理：对于素数p,有(p-1)!=-1( mod p).-
首先，将原式变形为[ (3×k+6)! % (3×k+7) + 1] / (3×k+7)，所以：-
(1)3×k+7是素数，结果为1,-
(2)3×k+7不是素数，则假设（3×k+7）=m1*m2*m3……，可知m1,m2,m3……<=3*k+6,则此时（3×k+6)! % (3×k+7) = 0,所以经过取整，式子的答案为0;.

poj-1313; Kaeya; 20190927; simulation;-
给一个n表示有1~n为有内容的页码，用最少的纸张做成折叠小册，使页码按册子翻页的顺序排好，从最外面的纸张开始输出每张纸上的正面反面的页码;-
每一面的页码对应一个最小一个最大，一个次大一个次小……以此类推，正面右半页为小页码，背面左半页为小页码，模拟即可。;.

CodeForces 580D; xxmlala; 20190927; States Compressing DP;-
每道菜都对应一个满意度，并且相互之间以特定的顺序排列有不同的满意度加成，从n道菜中选择m道，使得满意度最大;-
状态压缩dp裸题，以吃到的菜为状态，求解dp值即可;.

poj-1129; Caution_X; 20190927; DFS,graph theory,four colour theorem;-
给定n个点的无向连通图，问至少需要几种颜色可以完成染色;-
(1)任选从一点开始染色-
(2)DFS不断向其他点进行染色-
(3)所有点都染过色，结束DFS;.

hdu-1262; Caution_X; 20190927; brute force, Eular filter;-
给定一个数n，输出a,b满足a+b=n且a,b为素数且|a-b|最小;-
欧拉筛预处理素数，然后遍历所有素数即可，循环结束条件为素数大于n/2;.

CodeForce 113B; Caution_X; 20190927; DP;-
求多个数列的LCS;-
(1)dp[i]:表示以数字i结尾得到的LCS，pos[i][j]表示数字j再第i个数列的位置，cnt[i]表示数字i出现了几次-
(2)从每个数列第一个数开始往后遍历，当cnt[i]=k时说明i可以作为LCS的一部分了-
(3)接下来需要讨论一下，在LCS中加入i对答案的影响-
(4)我们用vector<>存入所有可以作为LCS一部分的值，然后遍历vector中的数，判断二者的pos，来决定i应该插入在哪一个位置-
(5)遍历完成后vector<>加入i并且重新从2步骤开始;.
